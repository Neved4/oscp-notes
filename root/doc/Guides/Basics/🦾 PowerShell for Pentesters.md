List content from `HKCU:\Software\Microsoft\Windows\CurrentVersion\`:

```powershell
cd HKCU:
Set-Location HKCU:
ls \Software\Microsoft\Windows\CurrentVersion\
```

Create new alias:

```powershell
New-Alias -Name listAliases -Value Get-Alias
```

List available modules:

```powershell
Get-Module -ListAvailable
```

List cmdlets from module `PSReadLine` :

```powershell
Get-Module -ListAvailable |
	Where-Object { $_.Name -like "*PSReadLine*" } |
	ForEach-Object { $_.exportedCommands }
```

List help:

- cmdlet: `Get-Help`
- function: `help`
- alias: `man`
- arg: `-?`
- Powershell ISE

Levels of help:

- `Get-Help <cmdlet>`
- `Get-Help <cmdlet> -detailed`
- `Get-Help <cmdlet -full`

Examples with:

```powershell
Get-Help <cmdlet> -examples
```

- It can offer help on things that are not cmdlets.
- It's able to show help on control flow statements: `help *`, `help if`.

#### Getting Help

- _helpfiles_ are help pages that contain the information.
- To navigate them we use `Get-Help` or `help`
- They have assigned the `HelpFile` category.

Download help with:

```powershell
> Update-Help
Updating Help for module Microsoft.PowerShell.Utility [Installing Help content]
```

List help for a particular element:

```powershell
> Get-Help if   
                                                                                                                        
Name                              Category  Module                    Synopsis
----                              --------  ------                    --------
New-ModuleManifest                Cmdlet    Microsoft.PowerShell.Core …
Test-ModuleManifest               Cmdlet    Microsoft.PowerShell.Core …
Update-ModuleManifest             Function  PowerShellGet             …
Update-PSModuleManifest           Cmdlet    Microsoft.PowerShell.PSR… Update-PSModuleManifest…
Get-PfxCertificate                Cmdlet    Microsoft.PowerShell.Sec… Get-PfxCertificate…
```

```text
> help about_if

ABOUT_IF

Short description

Describes a language command you can use to run statement lists based on
the results of one or more conditional tests.

Long description

You can use the if statement to run code blocks if a specified conditional
test evaluates to true. You can also specify one or more additional
conditional tests to run if all the prior tests evaluate to false. Finally,
you can specify an additional code block that's run if no other prior
conditional test evaluates to true.
```

```
> Get-Help -examples Get-ChildItem

NAME
    Get-ChildItem
    
SYNOPSIS
    Gets the items and child items in one or more specified locations.
    
    --- Example 1: Get child items from a file system directory ---
    
    Get-ChildItem -Path C:\Test
    
    Directory: C:\Test
    
    Mode                LastWriteTime         Length Name
    ----                -------------         ------ ----
    d-----        2/15/2019     08:29                Logs
    -a----        2/13/2019     08:55             26 anotherfile.txt
    -a----        2/12/2019     15:40         118014 Command.txt
    -a----         2/1/2019     08:43            183 CreateTestFile.ps1
    -ar---        2/12/2019     14:31             27 ReadOnlyFile.txt
    
    By default `Get-ChildItem` lists the mode ( Attributes ), LastWriteTime , file size ( Length ), and the Name of the item. The letters in 
    the Mode property can be interpreted as follows:
```

### Basic Commands

#### Filesystem Commands

| cmdlet                              | Description                   |
| ----------------------------------- | ----------------------------- |
| `Get-ChildItem` (`ls`)              | List the contents of a folder |
| `Set-Location` (`cd`)               | Changes working path          |
| `Get-Location` (`pwd`)              | Shows working path            |
| `New-Item` (`ni`, `md`)             | Creates files and folders     |
| `Remove-Item` (`del`, `rm`, `rmdi`) | Deletes files and folders     |
| `Move-Item` (`mv`, `move`)          | Move files or directories     |
| `Copy-Item` (`cp`, `copy`)          | Copy files or directories     |
| `Rename-Item` (`ren`)               | Rename files or directories   |

Create a file `test.txt`:

```powershell
New-Item -Name test.txt -ItemType file

    Directory: /Users/darwin

UnixMode         User Group         LastWriteTime         Size Name
--------         ---- -----         -------------         ---- ----
-rw-r--r--     darwin staff      11/28/2024 18:18            0 test.txt
```

#### File management

| cmdlet            | Description                                                                 |
| ----------------- | --------------------------------------------------------------------------- |
| Get-Content (cat) | View the contents of a file                                                 |
| Set-Content       | Dump the contents to a file. Use `toString()` before dumping                |
| Out-String        | Format the output before writing in the file                                |
| >                 | Creates file / erases content if file exists                                |
| >>                | Append content to the file if it exists, create if it doesn't               |
| Add-Content       | Append content to a file                                                    |
| Clear-Content     | Empties a file contents                                                     |
| Select-String     | Search file contents (`select-string .txt -pattern 'alias' -casesensitive`) |

#### Enviroment

| cmdlet                | Description                                           |
| --------------------- | ----------------------------------------------------- |
| `Write-Host`          | Writes to the screen                                  |
| `Write-Output` (echo) | Writes to the screen                                  |
| `Read-Host`           | Reads input values, with optional type                |
| `Get-Member`          | Get info from an object, type, properties and methods |
| `Where-Object`        | Filter results from a cmdlet. Temp variable `$_.`     |
| `Select-Object`       | Select fields from an object                          |
| `Sort-Object`         | Sort based on properties                              |
| `Get-Command`         | Return a list of modules and commands in PowerShell   |

```powershell
> $values=Read-Host "Input some text"

Input some text: hello
hello

> ls variable: | findstr values
values    hello

> [int]$values=Read-Host "Enter a number"

Enter a number: red

**MetadataError: Cannot convert value "red" to type "System.Int32". Error: "The input string 'a' was not in a correct format."**

> $values | Get-Member # List types and info

> valuesStr = $values.ToString()

> ($valuesString).Length
```

`Format-Table`:

```powershell
Get-Process | Format-Table -property id, processName -Autosize
```

### Execution Policies

- Avoids executing scripts without being authorized or without user's knowledge.
- Check with `Get-ExecutionPolicy` and `Set-ExecutionPolicy` as administrator.
- 4 main types of policies:
  - `Restricted`: Doesn't allow any execution. PowerShell can be used to invoke commands but not scripts. It's the default.
  - `Unrestricted`: Allows to execute any script regardless of origin, local or remote.
  - `RemoteSigned`: Scripts not created in the machine need to be signed in order to be executed.
  - `AllSigned`: Both local or remote scripts need to be signed to be executed. It's necessary to have the certificates in order to validate the signature and run the script. It's the strongest policy, bc it requires every script to have a signature.
- The scopes allow a richness and distinction to PowerShell execution policies. In version 1 only existed the scope `localmachine`, that made reference to the entirety of the local machine.
- Then appeared different scopes
  - `Process`: Exec policy impacts any running process, ie, the PowerShell session. It's not persistent.
  - `CurrentUser`: Affects the current user. It's stored in Window's registry, so it's persistent.
  - `LocalMachine`: Policy affects all users of the machine. It's stored with persistence under registry's `HKEY_LOCAL_MACHINE`
- Priority order is as follows `Process` > `CurrentUser` > `LocalMachine`

##### Scopes example

```powershell
Get-ExecutionPolicy -list                                                                                     
        Scope ExecutionPolicy
        ----- ---------------
MachinePolicy    Unrestricted
   UserPolicy    Unrestricted
      Process    Unrestricted
  CurrentUser    Unrestricted
 LocalMachine    Unrestricted
 
Set-ExecutionPolicy -Scope LocalMachine allsigned
```

### Remote Execution

- Need to enable remote admin in PowerShell
- Cmdlet: `Enable-PSRemoting`, (disable with `Disable-PSRemoting`)

Machines involved in remote admin need to take into account:

- That `WinRM` service is running
- That `WSMan`'s `trustedhosts` has the name of the machine we're accessing from into PowerShell.

  ```powershell
  New-PSSession -ComputerName bit-pc -Credential $cred
  ```

- Ensure `WinRm` service:
  - `Set-Service WinRM -StartMode Automatic`
  - `Get-WmiObject -Class win32_service | Where-Object {$_.name -like "WinRM"}`

- Trusted host in `WSMan`:
  - `Set-Item WSMan:localhost\client\trustedhosts -value <machine name>`
  - `Get-Item WSMan:\localhost\Client\TrustedHosts`

- Create a remote session:
  ```powershell
  New-PSSession -ComputerName <machine name> -Credentials (Get-Credential)
  ```

- Limit open sessions (background) with `New-PSSession`:
  ```powershell
  Get-PSSession
  $session = Get-PSSession -id 7
  ```

- Run a command on the session:
  ```powershell
  Invoke-Command -Session $session -ScriptBlock {pwd}
  ```

- Open interactive shells through `Enter-PSSession`:
  ```powershell
  Enter-PSSession -ComputerName bit-pc -Credential (Get-Credential)
  ```

- Check service is running:
  ```powershell
  Get-WmiObject -Class win32_service | Where-Object {$_.name -eq "WinRM"}

  ExitCode  : 0
  Name      : WinRM
  ProcessID : 332
  StartMode : Auto
  State     : Running
  Status    : OK
  ```

- Close a session
  ```powershell
  Remove-PSSession -Id 2
  ```

### Secure strings

- When a script grabs a sensible value like a credential, the cmdlet `Read-Host` has a special parameter `-assecurestring`.
- It allows the object to not be read directly, the string is protected and safe from attackers.
  ```powershell
  $sec = Read-Host -AsSecureString
  *****

  $sec
  System.Security.SecureString
  ```

### Methods to treat secure strings:

| Method                          | Description                                                   |
| ------------------------------- | ------------------------------------------------------------- |
| `AppendChar`                    | Appends a char to the secure string                           |
| `Copy`                          | Copies the object that is inside the secure string            |
| `Dispose`                       | Frees all resources that are under the object                 |
| `MakeReadOnly`                  | Content is made constant and can't be modified                |
| `InsertAt`, `RemoveAt`, `SetAt` | Inserts, removes or modifies a char in the specified position |

#### Reading secure chains

- A method where PowerShell's garbage collector can't intervene in a specific memory location.
- It copies the value of the secure string to a place where the garbage collector lacks access.
- Method `SecureStringToBSTR`, we obtain a pointer to a zone in memory not managed by the collector.
- With `PtrTroStringUni` we duplicate the content of the string but in plain text.

```powershell
$sec = Read-Host -AsSecureString
*****
$ptr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($sec)
$plain = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($ptr)
$plain
test
```

- `Get-Credential` stores the user info about passwords or name in a graphical interface when executing the cmdlet.
- Type `PSCredential` that has 2 fields, user and pass. User is type `String` and pass type `SecureString`
- Can be used to copy or move files with different credentials
- Or launch processes as a different user
- Other uses too with `cmdlet -Credential`

#### Signed Scripts

- Requires both `Microsoft Windows SDK` + Computer as CA and creating that certification authority.
- Create the cert:
  ```powershell
  makecert -n "CN=PowerShell i64" -a sha1 -ss MY -pe -eku 1.3.6.1.5.5.7.3.3 -iv root.pvk -ic root.cer
  Succeeded
  ```
- Sign the script
  ```powershell
  $cert = ls -Path cert:\CurrentUser\My -CodeSigningCert
  Set-AuthenticodeSignature .\5processes.ps1 -Certificate $cert
  ```
